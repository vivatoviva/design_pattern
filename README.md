## 面向对象中常见的设计模式


* [面向对象中常见的设计模式](#面向对象中常见的设计模式)
  * [工厂模式（创建型模式）](#工厂模式创建型模式)
  * [代理模式（结构型模式）](#代理模式结构型模式)
  * [装饰者模式（结构型模式）](#装饰者模式结构型模式)
  * [适配器模式（结构型模式）](#适配器模式结构型模式)
  * [策略模式（行为型模式）](#策略模式行为型模式)
  * [状态模式（行为型模式）](#状态模式行为型模式)
  * [模版模式](#模版模式)
  * [中间件（Middleware）](#中间件middleware)
  * [命令模式（行为型模式）](#命令模式行为型模式)
* [补充](#补充)
  * [单例模式（创建型模式）](#单例模式创建型模式)
  * [享元模式（结构型模式）](#享元模式结构型模式)
  * [桥接模式（结构型模式）](#桥接模式结构型模式)
  * [中介者模式 （行为型模式）](#中介者模式-行为型模式)
  * [观察者模式（行为型模式）](#观察者模式行为型模式)
  * [发布订阅模式（行为型模式）](#发布订阅模式行为型模式)
  * [node社区原则](#node社区原则)
  * [设计模式六大原则](#设计模式六大原则)
  * [总结](#总结)

#### 工厂模式（创建型模式）

定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行，从某些方面来说，相比于使用new 或者 object.create方法来创建对象，调用工厂方法是更为灵活和方便的方法。工厂模式的好处是可以保证我们不暴露创建对象的构造方法，避免被其继承或者修改，并且符合最小暴露原则，在Node中可以仅仅暴露出工厂方法从而保证每个构造函数的都是私有的。

###### 模式扩展

- 可组合的工厂模式

  可以被组合起来构建新的增强的工厂模式。通常我们会使用[stamp](https://github.com/vigour-io/stamp)来实现。

- 揭示构造函数

  这是一种比较新的设计模式，比如在Promise中有使用，当我们生成一个Promise对象的时候，传入一个执行函数作为构造函数的参数，该函数会在Promise中被调用来更改Promise的状态，并且只有构造函数可以访问resolve和reject两个方法，没有其他的代码可以调用reject和resolve方法和改变对象的内部状态。

- 总结（摘抄）

  - 创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。
  - 简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
  - 简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
  - 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。
  - 简单工厂模式最大的优点在于**实现对象的创建和对象的使用分离**，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于**工厂类不够灵活**，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。
  - 简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。

###### 理解：

自己对于这个模式的理解就是可以使用这个模式封装创建的对象的构造函数，类似于Koa框架中，可以同时暴露出两种方式来生成一个全新的服务器对象。根据书上说的，可以在此模式上扩展出多种工厂模式，一种是可组合的工厂模式，另一种是揭示构造函数

#### 代理模式（结构型模式）

代理是一个用来控制对另一个对象（称之为本体）访问的对象，代理对象可以拦截所有对本体对象执行的操作，补充或者增强他们的行为，从而封装本体对象的真实接口，从而保持其内部状态。实现代理模式目前有三种方法，一种是通过对象组合的方式实现，这是一种最安全的方法，另一种是对象增强的方法，这种方法直接修改本体对象，是一种最实用的方法，另一种就是es6中Proxy对象也可以实现代理。

###### 实现方式

- 对象组合（最安全）

  这种方法通过伪继承的方法实现代理，回本体对象无法被外部进行访问，本体对象的原始行为不会被更改，缺点就是我们需要实现要使用的所有方法。

  ```javascript
  functio createProxy(subject) {
      return {
          hello() {
              console.log(subject.hello(), 'proxy');
          },
          goodbye() {
              console.log(subject.goodbye(), 'proxy');
          }
      }
  }
  ```

- 对象增强（最实用）

  这种实现方式将回直接更改本体的相关方法，通过更改来增强相关对象本体的方法，

  ```javascript
  function createProxy(subject) {
      const hello = subject.hello;
      subject.hello = () => {
          hello.call(this);
          console.log('world')
      }
      return subject;
  }
  ```

  个人感觉这种方法不是很好，可能和函数方式的编程有点关系，这种直接修改原对象的房补不符合可预测性

- es6中的Proxy对象

  通过这个api我们可以实现很多的场景，比如说元编程、操作符重载、对象虚拟化等等。

###### AOP-面相对象的行为编程

node生态系统中的代理模式是-函数钩子与面向对象的行为编程（AOP），这种模式允许设计者为某一方法设置pre-或者post-的钩子，在指定方法运行前或者运行后可以执行自定义的代码。有的时候，代理模式还允许类似中间件管道的方式为 同一个方法注册多个钩子。

```javascript
Function.prototype.after = function(afterfn) {
  const self = this;
  return function () {
    const ret = self.apply(self, arguments);
    afterfn.apply(this, arguments);
    return ret;
  }
}

Function.prototype.before = function (beforefn) {
  const self = this;
  return function() {
    beforefn.apply(this, arguments);
    return self.apply(this, arguments);
  }
}
```



###### 保护代理和虚拟代理

保护代理就是代理可以帮助本体过滤一些请求，虚拟代理就是把一些开销很大的对象，延迟到真正需要他的时候才去创建

###### 其他的代理模式

- 防火墙代理：

  控制网络资源的访问，保护主体不让坏人接近

- 远程代理

  为一个对象在不同的地址空间提供局部代表，在Java中，远程代理可以是另一个虚拟机中的对象

- 保护代理

  用户对象应该有不同访问权限的情况

- 智能引用代理

  取代简单的指针，他在访问对象时执行一些附加操作，比如计算一个对象被引用次数

- 写时复制代理

  通常用于复制一个庞大对象的情况，写时复制代理来延迟了复制的过程，当对象真被修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL（动态链接库）是其典型运用场景。

- 例子

  - [delegates](https://github.com/tj/node-delegates)

###### 理解：

这个模式应该是很有用的一种设计模式，通过代理模式我们可以将对象的职责进行划分，使其符合单一职责原则，在js中可以有多种实现方式，一种就是通过对象组合，另一种是通过对象增强，同时我们应该了解到在JS中函数都都有相同的接口，所以也可以说闭包也是实现了代理模式，代理模式和装饰者模式、适配器模式容易搞混，但是我们应该通过模式解决的问题来思考这几种模式的不同。

#### 装饰者模式（结构型模式）

装饰者模式和代理模式很相似，但是他并不是增强和修改一个对象的现有方法，而是通过添加新的功能。实现装饰者模式也是有两种方法，一种是组合另一种是对象增强，相当于本地对象的基础上增加新的方法，从而增强对象。

- 例子
  - [level-inverted-index](https://github.com/dominictarr/level-inverted-index)
- 和代理模式的不同

###### 代理模式和装饰者模式区别

代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直 接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系(Proxy 与它的实体之间的关系)，这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理本体的引用，而装饰者模式经常会形成一条长长的装饰链。装饰者模式是实实在在的为对象增加新的职责和行为，而代理做的事情还是跟本体
一样，完成相同的功能。

###### 理解

装饰者模式是添加一个对象的现有方法，来增加对象，同理我们也可以想到函数这种特殊的类型，我们通过after和before两个方法来为函数添加新的功能，而不影响到函数现在的功能，那么为了增强对象或者增强函数的模式，我们称之为装饰者模式。也可以通过这种方法实现函数的代理，所以在js中实现方法是很模糊的，区分每种函数的功能主要是看解决的问题。

#### 适配器模式（结构型模式）

适配器模式允许我们通过一个不同的接口去使用原有对象的方法，他能适配一个对象，以便该对象能被拥有不同接口的组件去使用。

- 例子

  - [jugglingdb](https://github.com/1602/jugglingdb)


###### 适配器模式、装饰者模式、代理模式不同

适配器模式、装饰器模式、代理模式都是由一个对象包装另一个对象，区别他们的关键是他们的意图，三种模式虽然都是通过包装，但是解决的问题不同，所以形成了三种模式。

- 适配器模式主要是用来解决两个已有接口不匹配的问题，它不考虑这些接口是怎么实现的，也不考虑他们将来如何演化，适配器模式不需要改变已有的接口，就能够使他们协同工作。
- 装饰者模式的代理模式也不会改变原有的对象的接口，但是装饰模式的作用是为了给对象增加功能，装饰者模式通常形成一条长的装饰链，而适配器模式通常只包装一次，代理模式是为了控制对对象的访问，通常也只包装一次。

###### 理解

这个模式理解起来比较简单，比如生活中的Type-c转USB转接口，mac上面中扩展器等等，这种例子在生活中非常多，同样在js中实现适配器模式的方法也是很多，所以就不具体的来讲这种模式的实现，这里说下另一个模式，外观模式，区分这两种模式的区别，适配器可能针对性的适配，将两个不同的接口结合起来，但是外观模式还是有点不同，一种就是外观模式是通过创造一个新的接口来封装子系统，从而让外界更好的使用子系统，不需要了解子系统中各种复杂的逻辑关系。

#### 策略模式（行为型模式）

策略模式允许一个称之为上下文的对象，将变量部分提取到独立的、可变换的策略对象中，从而支持逻辑上的变化，上下文部分实现一套算法的**公共逻辑部分**，而策略实现了**可变部分**，允许上下文根据不同的因素，通过系统配置或者用户选择来调整它的行为，策略通常是解决方案的一部分，并且是实现了上下文所期望的部分（有点像依赖注入的模式），这种模式使得系统灵活的选择及解决途径，也能够方便的增加新的解决途径，也可以解决硬编码的问题，但是有一个问题，就是当我们选定了一种策略，策略将在上下文的生命周期内保持不变。下面我将举例说明这个问题：

```javascript
// 普通实现
class SayHello {
  say(type) {
    if (type === 'teach') {
      console.log('teach hello')
    } else if (type === 'student') {
      console.log('student hello')
    }
  }
}
const hello = new SayHello();
hello.say('teach');

// 使用策略模式实现
class SayHello {
  constructor(strategy) {
    this.data = {};
    this.strategy = strategy; // 传入的策略对象
  }
 
  say() {
    console.log(this.strategy(), 'hello');
  }
}
const student = new SayHello(() => 'student');
const teachHello = new SayHello(() => 'teach');
```

对于上述选择策略的方式，我们还可以还用其他的策略，比如

- 根据文件的后缀来动态选择策略，config 对象回维护一份后缀和策略的对应表，我们能根据文件后缀来选择相应的处理策略



###### 优缺点分析

优点：

- 提供对开闭原则的完美执行，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活的增加新的算法和行为
- 提供管理相关的算法族的方法
- 提供可以替换继承关系的方法
- 可以避免多重条件转移语句

缺点：

- 客户端必须知道所有的策略，并自行解决使用哪一种，这种违反最小知识原则
- 将回产生很多的策略类，可以通过使用享元模式在一定程度上减少对象的数量

###### 理解

这种模式就是将不变的部分封装起来，将变得的部分作为依赖或者参数传入，这种模式符合开放封闭原则的，可以同样我们不仅仅要想到通过对象来实践这种原则，同时我们也要想到通过函数来实践这个原则，将不变的部分封装成函数流程，然后将变得部分抽离传来，通过参数的方式传入函数来实现策略模式。策略模式中还可以进行更多的拓展，比如其中如何避免条件语句等等

#### 状态模式（行为型模式）

状态模式是策略模式的一种变形，其中的策略是根据上下文状态来进行改变。不同于策略模式，策略模式中，策略的选择基于不同的变量，一旦选择完成，策略在上下文中的生命周期就保持不变。但是现在我们需要在context生命周期中，我们可以动态改变一个状态，同时根据根据这个状态我们可以同时更改现在的模式，表现出不同的行为。现在我们举例说明这个问题：

```javascript
const net = require('net');
class OfflineSate {
  constructor(failSafeSocket) {
    this.failSafeSocket = failSafeSocket;
  }

  send(data) {
    this.failSafeSocket.queue.push(data);
  }

  activate() {
    const retry = () => {
      setTimeout(() => {
        this.activate();
      }, 5000);
    }
    this.failSafeSocket.socket = net.createConnection(this.failSafeSocket.options, () => {
      this.failSafeSocket.changState('online')
    });
    this.failSafeSocket.socket.once('error', retry);
  }
}

class OnlineState {
  constructor(failSafeSocket) {
    this.failSafeSocket = failSafeSocket;
  }
  
  send(data) {
    this.failSafeSocket.socket.push(data);
  }

  activate() {
    this.failSafeSocket.queue.forEach(data => {
      this.send(data);
    })
    this.failSafeSocket.queue = [];
    const hiddenError  = () => {
      this.changState('offline');
    }
    this.failSafeSocket.once('error', hiddenError);
  }
}

class FailSafeSocket {
  constructor(options) {
    this.options = options;
    this.queue = [];
    this.currentState = null;
    this.socket = null;
    this.states = {
      offline: new OfflineSate(this),
      online: new OnlineState(this),
    }
    this.changState('offline')
  }
  send(data) {
    this.currentState.send(data)
  }

  changState(state) {
    this.currentState = this.states[state];
    this.currentState.activate();
  }
}
```

这个例子是一个通过socker发送信息的类，当socket断开的时候，我们可以通过改变对象状态，同时改变对象方法中使用的策略，当网络好的时候又会再次改变状态，同时也会改变对象使用的策略，通过这种方式我们实现发送信息的不间断，这个类是策略模式的一种良好实现

###### 优缺点分析

优点：

- 封装了转化规则
- 将所有与某个状态有关的行为放到一个类中，并且方便增加新的状态，只需要改变对象状态即可改变对象行为
- 将状态转化逻辑与状态对象合成一体，而不是某一个巨大的条件语句块
- 可以让多个对象共享一个状态对象（享元模式），从而减少系统中对象的个数

缺点：

- 状态模型的结构和实现比价复杂，如果使用不当将回造成程序结构和代码的混乱
- 对开闭原则支持读不是很好，对于切换状态的状态模型，增加新的状态需要修改那些负责状态转化的源代码
- 虽然避开了不受欢迎的条件分支语句，但是也造成逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑

###### 性能优化点

- 将state分为两种，第一种是仅当state对象被需要时才创建并随后销毁，另一种就是创建好所有状态对象，并且始终不销毁他们

- 使用享元模式共享相关状态。

###### 状态模式和策略模式的不同

状态模式和策略模式像是一对双胞胎，他们都封装了一系列的算法或者行为，他们的类图看起来很相似，但是在意图上却有很大的不同，他们的相同点是他们都有一个上下文、一些策略或者状体类，上下文把请求委托给这些类来执行，他们之间的区别就是策略模式中各个策略类之间都是平等又平行的，他们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户可以随时主动的切换算法，而在状态模式中，状态和状态对应的行为早已经被封装好，状态之间的切换也是早被规定完成，“改变行为”这件事情发生在状态模式内部，对客户来说并不需要了解都这些细节，这正是状体模式的作用所在。



###### 表驱动的有限状态机

另一种实现状态机的方法，这种方法是基于表驱动的，我们可以在表中很清楚的看到下一个状态是由当前状态和行为共同决定的。

[Javascript State Machine](https://github.com/jakesgordon/javascript-state-machine)

###### 理解

状体模式和策略模式很像，但是相比策略模式解决的问题又有很大的不同，比如我们在策略模式中，每种策略仅仅封装功能实现方法并且各种策略是同等关系，就是一种实现方法，不存在更改策略的情况，但是在状态模式，每种状态不仅仅封装实现方法，同时包含状态的切换方法，然后生成的实体店来活动中会不断有逻辑的更改自己的方法，举个例子来说明下两种模式的不同，比如说老师发试卷考试，每个学生都有一种实现方法，这种就是策略模式，但是还有一种情况，就是考试成绩出来了，老师让每个人按照成绩高低依次到黑板上把自己的答案写下来，这种就可以理解为状态模式，不仅有存在实现方法同时存在状态切换顺序。同时状体模式的应用范围很大，扩展性也更加优秀，比如说通过一种表驱动的有限状态机，但是我们需要理解状态模式存在的问题，因为状态模式将状态切换同时放在状态中，所以造成逻辑分散，不能在一处来了解到整个系统的张台切换流程。

#### 模版模式

模版模式和策略模式也有很多相同的点，通过继承的方式让子类重写父类的方法，使用C++相关的术语称之为抽象函数和纯虚拟函数。策略模式允许我们在程序运行的时候动态指定算法，模版模式在定义的时候就已经确定了使用的算法。模版模式允许我们通过重用父模版继承来的逻辑和接口，同时实现很少一些抽象方法来获得一个全新的、功能完善的功能类。

###### 理解：

这个模式在js中存在感不是很高，因为js中没有接口的概念，同时js是原型类语言，不同于面向对象类型存在抽象等定义，但是我们在实现其他模式的时候可以来使用这个模式保证我们继承的方法实现了父类定义的方法，保证生成的对象重写相关方法，具有一致的接口。

#### 中间件（Middleware）

被称之为node中最特别的设计模式，中间件在企业中用来表示各种软件套件，他们有助于抽象底层机制，例如操作系统的API、网络通信和内存管理。但是在node中，中间件代表的是一系列的服务，通常指的是函数，他们以管道的方式被连接起来处理Http请求和响应，在koa框架中，中间件模型被扩展为洋葱模型：

![类型](![FVk0bj.png](https://s1.ax1x.com/2018/11/27/FVk0bj.png)

```javascript
// 实现洋葱模型
class Manage {
  use(...funs) {
    for (let fun of funs) {
      if (typeof fun !== 'function') throw new Error('params must is midleWare function');
  	}
    return function(ctx) {
      // let index = 0;
      // 创建next的函数，迭代创建
      // const createNext = (i) => {
      //   if (i < index) throw new Error('next() just invoke once');
      //   index++;
      //   if(index >= funs.length) {
      //     return () => ctx;
      //   }
      //   return function() {
      //     try {
      //       return Promise.resolve(funs[i + 1](ctx, createNext(i + 1)));
      //     } catch(error) {
      //       return Promise.reject(error);
      //     }
      //   }
      // }
      // return funs[index](ctx, createNext(0));
      let index = -1; // callback index
      const dispatch = (i) => {
        if(i <= index) return Promise.reject(new Error('next() just invoke once'));
        index = i;
        const fn = funs[i];
        if(!fn) return Promise.resolve();
        try {
          return Promise.resolve(fn(ctx, dispatch.bind(null, i + 1)));
        } catch(error) {
          return Promise.reject(error);
        }
      }
      return dispatch(0);
    }
  }
}
```



#### 命令模式（行为型模式）

命令模式是node中另一种重要的设计模式，通用的定义就是我们定义一个对象，之后由其他组件来完成调用，执行真正的操作，可以将命令模式看作是封装了即将要执行的操作所需要的信息的对象，所以，并不是直接调用一个方法或者函数，而是创建一个表示这种调用意图的对象，之后会由其他组件完成调用，执行真正的操作。通常来讲该设计模式由四个部分组成，一部分是Command对象，该对象的封装调用某个方法或者函数所必须的信息，client创建命令并提供给Invoker模块，Invoker负责在目标上执行命令，Target调用的主体，通常是一个函数。通常我们不会用到这种设计模式，因为请求者和实现者通常是一种紧耦合的关系，但是有的时候我们，我们需要对行为进行记录、撤销、重做或者事务等处理的时候，这种耦合我们就需要通过命令模式进行解耦。下面举一个例子：

[![FVAYw9.md.png](https://s1.ax1x.com/2018/11/27/FVAYw9.md.png)](https://imgchr.com/i/FVAYw9)

```javascript
// tager 部分
const target = {
    run() {
        console.log('函数调用');
    }
}
// 创建命令部分
const createCommand = (target) => {
    const command = () => {
        target.run();
    }
    return command;
}
// 命令调用类部分
class Invoker {
    constructor() {
        this.history = [];
    }

    run(command) {
        command && command();
        this.history.push(command);
    }
}
// client进行调用部分
const command = createCommand(target);
const invoker = new Invoker();
invoker.run(command);

```

###### 宏命令

这是一种扩展，我们可以通封装一系列命令，同样我们也可以实现和普通命令一样的撤销重做等等，

###### 理解：

命令模式标准是根据上面那张图，但是在js中我们中可以考虑函数来实现简单的命令模式，delegation函数也可以称之为一种命令模式，现在很大程度上使用命令模式主要是为了实现命令的撤销和重做，同时对于上面那个结构，根据是否存在target，我们可以将命令分为两类型，一种是傻瓜式命令，一种是智能式命令，当不存在target的时候，我们将这种命令称之为智能命令，这种命令和策略模式从代码结构上已经不能进行区分，能分辨的只有他们意图的不同，策略模式指向的问题域更小，所有策略对象的目标总是一致的，他们只是达到这种目标的手段，他们的内部针对的是“算法”而言，而智能模式指向的问题域更广，command对象解决的目标更具有发散性。命令模式还可以完成撤销、排队等功能。

### 补充

#### 单例模式（创建型模式）

让类自身负责保存他的唯一实例。这个类可以保证没有其他的实例被创建，并且他可以提供一个访问改实例的方法。单例模式确保某一类只有一个实例，而且自行实例化并向整个系统提供这个实力，提供全局访问的方法。

#### 享元模式（结构型模式）zhuag

享元模式主要是用来优化系统的性能，主要为了解决大量类似的对象而产生的性能问题，它最适合解决大量类似的对象而产生的性能问题，享元模式通过分析应用程序的对象，将其解析为内在数据和外在数据，减少对象的数量，从而提高应用程序的性能。通常享元模式由以下几部分组成：

- 客户端：用来调用享元工厂来获取内部的数据的类，通常是应用程序需要的对象
- 享元工厂：用来维护享元数据的类
- 享元类：保持内在数据的类

享元模式主要的划分内部状态和外部状态，有多少种内部状态，系统中便有多少种共享对象，而外部状态存储在共享对象外部，在必要的时候传入共享对象组装成一个完整的对象。其中区分内部状态和外部状态的关键点有以下几点：

- 内部状态存储于对象内部
- 内部状态可以被一些对象共享
- 内部状态独立于具体的场景，通常不会改变
- 外部状态取决于具体的场景，并且根据场景而变化，外部状态不能被共享。

适用情况如下：

- 一个程序中使用大量相似的对象
- 由于使用了大量的对象，造成很大的内存开销
- 对象的大多数状态都可以变为外部状态
- 剥离除对象的外部状态之后，可以用相对较少的共享对象取代大量对象

判断一个模式是不是享元模式的重要一点就是判断是不是区分内部状体和外部状态，有没有存在剥离外部状态的的过程，比如说JAVA和C#中对于字符串的创建是使用了共享技术，但是不存在剥离外部状态的过程，那么我们认为这并不是一个纯粹的享元模式。

###### 对象池技术

对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接 new，而是转从对象池里获取。如
果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入
池子等待被下次获取。

###### 理解

这个设计模式主要是为了优化系统而生，通过将对象的属性分为内部状态的外部状态，然后通过共享内部状态来减少系统中存在的对象数量，系统中存在多少种内部状态就存在多少种共享对象，而外部状态存储在对象的外部，必要的时候传入共享对象构建一个完整的对象，整个结构需要存在享元工厂，用来创建共享对象，外部属性管理器，用来管理存在的外部属性，需要的时候将内部状态和外部状态结合起来进行使用。同时我们学习了对象池技术用来优化性能，同时对象池基础经过扩展还可以拥有更多的特性。



#### 迭代器模式（行为型模式）



###### 迭代器分类

- 内部迭代器

内部迭代器在调用的时候非常方便，外界不必关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，单这也正是内部迭代器的缺点，由于内部迭代器的迭代规则已经被提前规定，所以当我们存在新的需求，内部迭代器将回受到限制

- 外部迭代器

外不迭代器必须显式的请求迭代下一个元素，外部迭代器增加了一些调用的复杂度，但相对的也增加了迭代器的灵活性，我们可以手动控制迭代的过程或者顺序。适用面更广，能够满足更多的需求，下面是一个外部迭代器的实例：

```javascript
const Iterator = function (arr) {
  let current = 0;
  const next = function () {
    current += 1;
  }
  const isDone = function () {
    return current >= arr.length - 1;
  }

  const getCurrItem = function () {
    return arr[current];
  }

  return {
    next,
    isDone,
    getCurrItem,
  }
};

```

- 倒序迭代器
- 中止迭代

```javascript
function each (arr, callback) {
  for (let i = 0; i < arr.length; i++) {
    if (!callback(i, arr[i])) {
      break;
    }
  }
}
```

中止模块我们可以用来实现浏览器相关支持方法的验证。

###### 理解

迭代器模式也是践行单一职责的模式之一，我们将迭代的职责抽离出来，形成了四种迭代方式，一种是内部迭代、一种是外部迭代、一种是倒叙迭代、一种是中止迭代，我们可以通过者几种不同的迭代方式来实现相关的迭代需求，同时也可以通过AOP来简单实现迭代器的几种方式。

#### 桥接模式（结构型模式）

设想我们要绘制矩型、圆形、椭圆形、正方形、我们至少得需要四个形状类型，但是如果我们绘制的图形如果需要设具有不同的颜色，比如：红色、绿色、蓝色等等，现在我们有两种设计方案：

- 通过继承来为每一种形状都提供一套各种颜色的版本
- 根据实际需要对形状和颜色进行组合

采用方案二可以使得类的扩展变得更加容易，同时系统中类也更加少了，这就是桥接模式，将继承关系转化成关联关系，从而降低类与类之间的耦合，减少代码的编写量。将类的功能层次和实现层次结构相分离，使二者能够独立的变化，并在两者之间搭建桥梁，实现侨接模式。

###### 理解

前端中基本不存在这个问题，我们简单的将对象组合到一起形成一个新的对象

#### 外观模式（行为型模式）

外观模式作用是对客户屏蔽一组子系统的复杂性，外观模式为客户提供一个简单易用的高层接口，高层接口会把客户的请求转发给子系统来玩车过具体的功能实现。大多数时候客户可以通过请求外观接口来达到访问子系统的目的，但在一段使用了外观模式的程序中，请求外观并不是强制的。如果外观模式不能满足用户的个性化需求，那么用户可以直接访问子系统。

###### 主要特点：

- 为一组子系统提供一个简单便利的访问入口
- 隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节

###### 理解

这个模式注意和装饰者模式的区别，上文已经提到

#### 中介者模式 （行为型模式）

对象之间存在相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机，可以使得对象之间的关系数量急剧减少。

![](https://ws4.sinaimg.cn/large/006tNbRwly1fxo7g63wazj30o709xwhs.jpg)

优点：

- 简化了对象之间的交互。
- 将各同事解耦。
- 减少子类生成。
- 可以简化各同事类的设计和实现。

缺点：

- 在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。

使用时机：

当系统中类相互耦合，形成了网状结构

#### 观察者模式（行为型模式）

建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应，发生改变的对象称之为观察目标，被通知的对象称之为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有联系，可以根据需要增加或者删除观察者，让系统更易于扩展。

优点：

- 观察者模式可以实现表示层和数据逻辑层的分离，并定义了未定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色
- 观察者模式在观察者和观察目标之间建立i一个抽象的耦合。
- 观测者支持广播通信
- 观察者模式符合开闭原则的要求

缺点：

- 如果一个观察目标存在很多直接或者间接的观察者，将所有的观察者都通知到将回话费很多的时间
- 如果观察目标和观察者之间存在循环依赖的话，观察目标会触发他们之间进行循环调用，可能导致系统崩溃。
- 观察者模式没有相应的机制让观察者知道观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

![](https://ws4.sinaimg.cn/large/006tNbRwly1fxo30d60xrj30ha0cfq2z.jpg)



#### 发布订阅模式（行为型模式）

发布订阅模式和观察者模式解决的问题相同，但是实现思路不同，这里我们就主要了解下发布订阅和常规观察者实现思路存在什么不同。

** 这两种方式本质上区别是调度中心不同，在观察者模式中，观察目标必须知道存在哪些观察者，当观察目标发生改变的时候将由观察目标去通知注册的观察者，但是在发布订阅模式里面：消息的发送方称之为发布者，消息的接收方称之为订阅者，但是发布者通常发送消息不会直接发送给特定的订阅者，而是直接发送给一个作为信息中介的称之为调度中心的组件。** 两者的区别如下：

- 发布订阅模式中发布者和订阅者者都不知道对方的存在，只有通过消息代理进行通信。这里面订阅者和发布者是松耦合的关系，观察者模式中两者是强耦合的关系。
- 发布订阅模式两者大多数时候是异步的（消息队列等等），观察者模式大多数时候是同步的
- 观察者模式需要在单个应用程序地址空间中实现，发布订阅更像是交叉应用模式

在node中事件系统是普通的观察者模式。

![](https://ws3.sinaimg.cn/large/006tNbRwly1fxo35jmdfhj30ji0b00sq.jpg)



#### node社区原则

- 小核心原则

node的设计原则就是小核心、易扩展的模式。node中将核心功能都抽象为各个模块，比如fs、path、stream、events、http等等。

- 小模块

通常指的是我们模块的范围比较小，让一个模块只做一件事情，并且将这件事情做好，同时小模块也意味着容易理解和使用，测试和维护简单，完美与浏览器共享，将代码发送到npm上，是将DRY（Dont`t repeat youself）原则最佳实现。

- 小接触面

小接触面原则指的是我们的模块只暴露出最小的一组功能的特性，让API的使用更加清晰，较少暴露出错误的使用。

- 简单和实用

Keep It Simple, Stupid (KISS) 原则，简单是复杂的最高境界，简单是设计中最重要的考虑因素，简单意味着允许较少的资源进行更快的传输；更加容易适应和维护。

#### 设计模式六大原则

- 单一职责原则（SRP）

这是一个开发常识，但是为什么还需要这一点提出来，因为随着系统的开发，类可能发生职责扩散，从而导致不符合单一原则，这种最好的解决方法就是实际中一旦发现类的职责发生扩散，就遵守单一原则为上策,SRP原则在很多设计模式中都有体现，比如通过代理模式将对象的职责进行分割，迭代器模式将遍历的职责提取出来，单例模式将创建对象的职责进行封装，装饰者模式让类一开始只具有一些基础的职责，更多的职责在代码运行的时呗动态的装饰到对象上。装饰者模式可以为对象动态的增加职责。何时应该进行分离职责，如果两个职责都是同时变化的，那个就不必分离，比如创建XHR和发送xhr请求，这两个职责就没必要进行分离。SPR优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的力度，者有助于代码的复用，有利于进行单元测试，但是这种方法会明显增加代码的复杂度，增加这些对象之间相互联系的难度。

- 里式替换原则

父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义，尽量不更改父类的相关方法。

- 依赖倒置原则

高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象.存在抽象得定义, 比如：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。解决方法就是将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率

- 接口隔离原则

定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 
问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。

解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。

- 迪米特原则（最少知识原则）

单一职责指导我们把对象划分成较小的粒度，这可以提高对象的可复用性，但越来越多的对象之间可能会产生错综复杂的联系，如果修改了其中一个对象，很可能影响到跟它相互引用的其他对象，对象和对象耦合在一起，有可能降低他们的可复用性。最少知识原则要求我们在设计应用程序的时候应该减少对象直接的交互，如果两个对象之间不必彼此直接通信，那么者两个对象就不要发生直接的相互联系，常见的做法是引入一个第三方对象来承担这些对象之间的通信作用。如果一些对象需要向零一些对象发起请求，可以通过第三方对象来转发这些请求。比如我们学习中介者模式、外观模式

定义：一个对象应该对其他对象保持最少的了解。

问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。

- 开闭原则（开放-封闭原则）

当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码，这就是开闭原则的思想。有一种说法就是几乎所有的设计模式都是遵守开放-封闭原则的，我们见到的所有好的设计都是遵守开发-封闭模式的考验，不管是具体的各种设计模式，还是更加抽象的面向对象的原则，比图单一职责原则、迪米伽原则、依赖倒置原则等，都是为了让程序遵守开放-封闭原则而出现的。可以说开放=封闭模式是编写好一个好程序的目标。其他的原则都是达到这个目标的过程。

```javascript
Function.prototype.after = function(afterFun) {
  const self = this;
  return function () {
    const result = self.apply(this, arguments);
    afterFun.apply(this, arguments);
    return result;
  }
}
```

定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。

解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。



#### 总结

本章学习了这几种模式，这几种模式在node中有很多种实现方式，没有一个标准，但是我们只要学习到这些模式的思想和要解决的问题，就可以了，等到遇见具体的问题，我们可以设计自己方式来实现这些有趣的模式。学习这些模块可以通过将这些模式分为三大类进行学习，一种是创建型模式、另一种是结构型模式、另一种是行为型模式。具体我们可以通过下面两个教程来了解目前面向对象的设计模式，主要是学习思想和解决的问题。后面我们了解了node的设计原则和设计模式遵守的原则。

- [菜鸟教程](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)
- [java中设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html)