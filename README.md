## 面向对象中常见的设计模式


* [面向对象中常见的设计模式](#面向对象中常见的设计模式)
  * [工厂模式（创建型模式）](#工厂模式创建型模式)
  * [代理模式（结构型模式）](#代理模式结构型模式)
  * [装饰者模式（结构型模式）](#装饰者模式结构型模式)
  * [适配器模式（结构型模式）](#适配器模式结构型模式)
  * [策略模式（行为型模式）](#策略模式行为型模式)
  * [状态模式（行为型模式）](#状态模式行为型模式)
  * [模版模式](#模版模式)
  * [中间件（Middleware）](#中间件middleware)
  * [命令模式（行为型模式）](#命令模式行为型模式)
* [补充](#补充)
  * [单例模式（创建型模式）](#单例模式创建型模式)
  * [享元模式（结构型模式）](#享元模式结构型模式)
  * [桥接模式（结构型模式）](#桥接模式结构型模式)
  * [中介者模式 （行为型模式）](#中介者模式-行为型模式)
  * [观察者模式（行为型模式）](#观察者模式行为型模式)
  * [发布订阅模式（行为型模式）](#发布订阅模式行为型模式)
  * [node社区原则](#node社区原则)
  * [设计模式六大原则](#设计模式六大原则)
  * [总结](#总结)



#### 工厂模式（创建型模式）

定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行，从某些方面来说，相比于使用new 或者 object.create方法来创建对象，调用工厂方法是更为灵活和方便的方法。工厂模式的好处是可以保证我们不暴露创建对象的构造方法，避免被其继承或者修改，并且符合最小暴露原则，在Node中可以仅仅暴露出工厂方法从而保证每个构造函数的都是私有的。

- 可组合的工厂模式

  可以被组合起来构建新的增强的工厂模式。通常我们会使用stamp来实现。

- 揭示构造函数

  这是一种比较新的设计模式，比如在Promise中有使用，当我们生成一个Promise对象的时候，传入一个执行函数作为构造函数的参数，该函数会在Promise中被调用来更改Promise的状态，并且只有构造函数可以访问resolve和reject两个方法，没有其他的代码可以调用reject和resolve方法和改变对象的内部状态。

- 总结（摘抄）

  - 创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。
  - 简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
  - 简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
  - 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。
  - 简单工厂模式最大的优点在于**实现对象的创建和对象的使用分离**，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于**工厂类不够灵活**，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。
  - 简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。

#### 代理模式（结构型模式）

代理是一个用来控制对另一个对象（称之为本体）访问的对象，代理对象可以拦截所有对本体对象执行的操作，补充或者增强他们的行为，从而封装本体对象的真实接口，从而保持其内部状态。实现代理模式目前有三种方法，一种是通过对象组合的方式实现，这是一种最安全的方法，另一种是对象增强的方法，这种方法直接修改本体对象，是一种最实用的方法，另一种就是es6中Proxy对象也可以实现代理。

- 对象组合（最安全）

  这种方法通过伪继承的方法实现代理，回本体对象无法被外部进行访问，本体对象的原始行为不会被更改，缺点就是我们需要实现要使用的所有方法。

  ```javascript
  functio createProxy(subject) {
      return {
          hello() {
              console.log(subject.hello(), 'proxy');
          },
          goodbye() {
              console.log(subject.goodbye(), 'proxy');
          }
      }
  }
  ```

- 对象增强（最实用）

  这种实现方式将回直接更改本体的相关方法，通过更改来增强相关对象本体的方法，

  ```javascript
  function createProxy(subject) {
      const hello = subject.hello;
      subject.hello = () => {
          hello.call(this);
          console.log('world')
      }
      return subject;
  }
  ```

  个人感觉这种方法不是很好，可能和函数方式的编程有点关系，这种直接修改原对象的房补不符合可预测性

- es6中的Proxy对象

  通过这个api我们可以实现很多的场景，比如说元编程、操作符重载、对象虚拟化等等。

node生态系统中的代理模式是-函数钩子与面向对象的行为编程（AOP），这种模式允许设计者为某一方法设置pre-或者post-的钩子，在指定方法运行前或者运行后可以执行自定义的代码。有的时候，代理模式还允许类似中间件管道的方式为 同一个方法注册多个钩子。

- 例子
  - [delegates](https://github.com/tj/node-delegates)

#### 装饰者模式（结构型模式）

装饰者模式和代理模式很相似，但是他并不是增强和修改一个对象的现有方法，而是通过添加新的功能。实现装饰者模式也是有两种方法，一种是组合另一种是对象增强，相当于本地对象的基础上增加新的方法，从而增强对象。

- 例子
  - [level-inverted-index](https://github.com/dominictarr/level-inverted-index)

#### 适配器模式（结构型模式）

适配器模式允许我们通过一个不同的接口去使用原有对象的方法，他能适配一个对象，以便该对象能被拥有不同接口的组件去使用。

- 例子
  - [jugglingdb](https://github.com/1602/jugglingdb)

#### 策略模式（行为型模式）

策略模式允许一个称之为上下文的对象，将变量部分提取到独立的、可变换的策略对象中，从而支持逻辑上的变化，上下文部分实现一套算法的**公共逻辑部分**，而策略实现了**可变部分**，允许上下文根据不同的因素，通过系统配置或者用户选择来调整它的行为，策略通常是解决方案的一部分，并且是实现了上下文所期望的部分（有点像依赖注入的模式），这种模式使得系统灵活的选择及解决途径，也能够方便的增加新的解决途径，也可以解决硬编码的问题，但是有一个问题，就是当我们选定了一种策略，策略将在上下文的生命周期内保持不变。下面我将举例说明这个问题：

```javascript
// 普通实现
class SayHello {
  say(type) {
    if (type === 'teach') {
      console.log('teach hello')
    } else if (type === 'student') {
      console.log('student hello')
    }
  }
}
const hello = new SayHello();
hello.say('teach');

// 使用策略模式实现
class SayHello {
  constructor(strategy) {
    this.data = {};
    this.strategy = strategy; // 传入的策略对象
  }
 
  say() {
    console.log(this.strategy(), 'hello');
  }
}
const student = new SayHello(() => 'student');
const teachHello = new SayHello(() => 'teach');
```

对于上述选择策略的方式，我们还可以还用其他的策略，比如

- 根据文件的后缀来动态选择策略，config 对象回维护一份后缀和策略的对应表，我们能根据文件后缀来选择相应的处理策略

优点：

- 提供对开闭原则的完美执行，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活的增加新的算法和行为
- 提供管理相关的算法族的方法
- 提供可以替换继承关系的方法
- 可以避免多重条件转移语句

缺点：

- 客户端必须知道所有的策略，并自行解决使用哪一种
- 将回产生很多的策略类，可以通过使用享元模式在一定程度上减少对象的数量

#### 状态模式（行为型模式）

状态模式是策略模式的一种变形，其中的策略是根据上下文状态来进行改变。不同于策略模式，策略模式中，策略的选择基于不同的变量，一旦选择完成，策略在上下文中的生命周期就保持不变。但是现在我们需要在context生命周期中，我们可以动态改变一个状态，同时根据根据这个状态我们可以同时更改现在的模式，表现出不同的行为。现在我们举例说明这个问题：

```javascript
const net = require('net');
class OfflineSate {
  constructor(failSafeSocket) {
    this.failSafeSocket = failSafeSocket;
  }

  send(data) {
    this.failSafeSocket.queue.push(data);
  }

  activate() {
    const retry = () => {
      setTimeout(() => {
        this.activate();
      }, 5000);
    }
    this.failSafeSocket.socket = net.createConnection(this.failSafeSocket.options, () => {
      this.failSafeSocket.changState('online')
    });
    this.failSafeSocket.socket.once('error', retry);
  }
}

class OnlineState {
  constructor(failSafeSocket) {
    this.failSafeSocket = failSafeSocket;
  }
  
  send(data) {
    this.failSafeSocket.socket.push(data);
  }

  activate() {
    this.failSafeSocket.queue.forEach(data => {
      this.send(data);
    })
    this.failSafeSocket.queue = [];
    const hiddenError  = () => {
      this.changState('offline');
    }
    this.failSafeSocket.once('error', hiddenError);
  }
}

class FailSafeSocket {
  constructor(options) {
    this.options = options;
    this.queue = [];
    this.currentState = null;
    this.socket = null;
    this.states = {
      offline: new OfflineSate(this),
      online: new OnlineState(this),
    }
    this.changState('offline')
  }
  send(data) {
    this.currentState.send(data)
  }

  changState(state) {
    this.currentState = this.states[state];
    this.currentState.activate();
  }
}
```

这个例子是一个通过socker发送信息的类，当socket断开的时候，我们可以通过改变对象状态，同时改变对象方法中使用的策略，当网络好的时候又会再次改变状态，同时也会改变对象使用的策略，通过这种方式我们实现发送信息的不间断，这个类是策略模式的一种良好实现

优点：

- 封装了转化规则
- 将所有与某个状态有关的行为放到一个类中，并且方便增加新的状态，只需要改变对象状态即可改变对象行为
- 将状态转化逻辑与状态对象合成一体，而不是某一个巨大的条件语句块
- 可以让多个对象共享一个状态对象，从而减少系统中对象的个数

缺点：

- 状态模型的结构和实现比价复杂，如果使用不当将回造成程序结构和代码的混乱
- 对开闭原则支持读不是很好，对于切换状态的状态模型，增加新的状态需要修改那些负责状态转化的源代码

#### 模版模式

模版模式和策略模式也有很多相同的点，通过继承的方式让子类重写父类的方法，使用C++相关的术语称之为抽象函数和纯虚拟函数。策略模式允许我们在程序运行的时候动态指定算法，模版模式在定义的时候就已经确定了使用的算法。模版模式允许我们通过重用父模版继承来的逻辑和接口，同时实现很少一些抽象方法来获得一个全新的、功能完善的功能类。

#### 中间件（Middleware）

被称之为node中最特别的设计模式，中间件在企业中用来表示各种软件套件，他们有助于抽象底层机制，例如操作系统的API、网络通信和内存管理。但是在node中，中间件代表的是一系列的服务，通常指的是函数，他们以管道的方式被连接起来处理Http请求和响应，在koa框架中，中间件模型被扩展为洋葱模型：

![类型](![FVk0bj.png](https://s1.ax1x.com/2018/11/27/FVk0bj.png)

```javascript
// 实现洋葱模型
class Manage {
  use(...funs) {
    for (let fun of funs) {
      if (typeof fun !== 'function') throw new Error('params must is midleWare function');
  	}
    return function(ctx) {
      // let index = 0;
      // 创建next的函数，迭代创建
      // const createNext = (i) => {
      //   if (i < index) throw new Error('next() just invoke once');
      //   index++;
      //   if(index >= funs.length) {
      //     return () => ctx;
      //   }
      //   return function() {
      //     try {
      //       return Promise.resolve(funs[i + 1](ctx, createNext(i + 1)));
      //     } catch(error) {
      //       return Promise.reject(error);
      //     }
      //   }
      // }
      // return funs[index](ctx, createNext(0));
      let index = -1; // callback index
      const dispatch = (i) => {
        if(i <= index) return Promise.reject(new Error('next() just invoke once'));
        index = i;
        const fn = funs[i];
        if(!fn) return Promise.resolve();
        try {
          return Promise.resolve(fn(ctx, dispatch.bind(null, i + 1)));
        } catch(error) {
          return Promise.reject(error);
        }
      }
      return dispatch(0);
    }
  }
}
```



#### 命令模式（行为型模式）

命令模式是node中另一种重要的设计模式，通用的定义就是我们定义一个对象，之后由其他组件来完成调用，执行真正的操作，可以将命令模式看作是封装了即将要执行的操作所需要的信息的对象，所以，并不是直接调用一个方法或者函数，而是创建一个表示这种调用意图的对象，之后会由其他组件完成调用，执行真正的操作。通常来讲该设计模式由四个部分组成，一部分是Command对象，该对象的封装调用某个方法或者函数所必须的信息，client创建命令并提供给Invoker模块，Invoker负责在目标上执行命令，Target调用的主体，通常是一个函数。通常我们不会用到这种设计模式，因为请求者和实现者通常是一种紧耦合的关系，但是有的时候我们，我们需要对行为进行记录、撤销、重做或者事务等处理的时候，这种耦合我们就需要通过命令模式进行解耦。下面举一个例子：

[![FVAYw9.md.png](https://s1.ax1x.com/2018/11/27/FVAYw9.md.png)](https://imgchr.com/i/FVAYw9)

```javascript
// tager 部分
const target = {
    run() {
        console.log('函数调用');
    }
}
// 创建命令部分
const createCommand = (target) => {
    const command = () => {
        target.run();
    }
    return command;
}
// 命令调用类部分
class Invoker {
    constructor() {
        this.history = [];
    }

    run(command) {
        command && command();
        this.history.push(command);
    }
}
// client进行调用部分
const command = createCommand(target);
const invoker = new Invoker();
invoker.run(command);

```

### 补充

#### 单例模式（创建型模式）

让类自身负责保存他的唯一实例。这个类可以保证没有其他的实例被创建，并且他可以提供一个访问改实例的方法。单例模式确保某一类只有一个实例，而且自行实例化并向整个系统提供这个实力，提供全局访问的方法。

#### 享元模式（结构型模式）

享元模式主要是用来优化系统的性能，主要为了解决大量类似的对象而产生的性能问题，它最适合解决大量类似的对象而产生的性能问题，享元模式通过分析应用程序的对象，将其解析为内在数据和外在数据，减少对象的数量，从而提高应用程序的性能。通常享元模式由以下几部分组成：

- 客户端：用来调用享元工厂来获取内部的数据的类，通常是应用程序需要的对象
- 享元工厂：用来维护享元数据的类
- 享元类：保持内在数据的类

#### 桥接模式（结构型模式）

设想我们要绘制矩型、圆形、椭圆形、正方形、我们至少得需要四个形状类型，但是如果我们绘制的图形如果需要设具有不同的颜色，比如：红色、绿色、蓝色等等，现在我们有两种设计方案：

- 通过继承来为每一种形状都提供一套各种颜色的版本
- 根据实际需要对形状和颜色进行组合

采用方案二可以使得类的扩展变得更加容易，同时系统中类也更加少了，这就是桥接模式，将继承关系转化成关联关系，从而降低类与类之间的耦合，减少代码的编写量。将类的功能层次和实现层次结构相分离，使二者能够独立的变化，并在两者之间搭建桥梁，实现侨接模式。

#### 中介者模式 （行为型模式）

对象之间存在相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机，可以使得对象之间的关系数量急剧减少。

![](https://ws4.sinaimg.cn/large/006tNbRwly1fxo7g63wazj30o709xwhs.jpg)

优点：

- 简化了对象之间的交互。
- 将各同事解耦。
- 减少子类生成。
- 可以简化各同事类的设计和实现。

缺点：

- 在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。

使用时机：

当系统中类相互耦合，形成了网状结构

#### 观察者模式（行为型模式）

建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应，发生改变的对象称之为观察目标，被通知的对象称之为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有联系，可以根据需要增加或者删除观察者，让系统更易于扩展。

优点：

- 观察者模式可以实现表示层和数据逻辑层的分离，并定义了未定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色
- 观察者模式在观察者和观察目标之间建立i一个抽象的耦合。
- 观测者支持广播通信
- 观察者模式符合开闭原则的要求

缺点：

- 如果一个观察目标存在很多直接或者间接的观察者，将所有的观察者都通知到将回话费很多的时间
- 如果观察目标和观察者之间存在循环依赖的话，观察目标会触发他们之间进行循环调用，可能导致系统崩溃。
- 观察者模式没有相应的机制让观察者知道观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

![](https://ws4.sinaimg.cn/large/006tNbRwly1fxo30d60xrj30ha0cfq2z.jpg)



#### 发布订阅模式（行为型模式）

发布订阅模式和观察者模式解决的问题相同，但是实现思路不同，这里我们就主要了解下发布订阅和常规观察者实现思路存在什么不同。

这两种方式本质上区别是调度中心不同，在观察者模式中，观察目标必须知道存在哪些观察者，当观察目标发生改变的时候将由观察目标去通知注册的观察者，但是在发布订阅模式里面：消息的发送方称之为发布者，消息的接收方称之为订阅者，但是发布者通常发送消息不会直接发送给特定的订阅者，而是直接发送给一个作为信息中介的称之为调度中心的组件。两者的区别如下：

- 发布订阅模式中发布者和订阅者者都不知道对方的存在，只有通过消息代理进行通信。这里面订阅者和发布者是松耦合的关系，观察者模式中两者是强耦合的关系。
- 发布订阅模式两者大多数时候是异步的（消息队列等等），观察者模式大多数时候是同步的
- 观察者模式需要在单个应用程序地址空间中实现，发布订阅更像是交叉应用模式

在node中事件系统是普通的观察者模式。

![](https://ws3.sinaimg.cn/large/006tNbRwly1fxo35jmdfhj30ji0b00sq.jpg)



#### node社区原则

- 小核心原则

node的设计原则就是小核心、易扩展的模式。node中将核心功能都抽象为各个模块，比如fs、path、stream、events、http等等。

- 小模块

通常指的是我们模块的范围比较小，让一个模块只做一件事情，并且将这件事情做好，同时小模块也意味着容易理解和使用，测试和维护简单，完美与浏览器共享，将代码发送到npm上，是将DRY（Dont`t repeat youself）原则最佳实现。

- 小接触面

小接触面原则指的是我们的模块只暴露出最小的一组功能的特性，让API的使用更加清晰，较少暴露出错误的使用。

- 简单和实用

Keep It Simple, Stupid (KISS) 原则，简单是复杂的最高境界，简单是设计中最重要的考虑因素，简单意味着允许较少的资源进行更快的传输；更加容易适应和维护。

#### 设计模式六大原则

- 单一职责原则

这是一个开发常识，但是为什么还需要这一点提出来，因为随着系统的开发，类可能发生职责扩散，从而导致不符合单一原则，这种最好的解决方法就是实际中一旦发现类的职责发生扩散，就遵守单一原则为上策

- 里式替换原则

父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义，尽量不更改父类的相关方法。

- 依赖倒置原则

高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象.存在抽象得定义, 比如：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。解决方法就是将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率

- 接口隔离原则

定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 
问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。

解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。

- 迪米特原则

定义：一个对象应该对其他对象保持最少的了解。

问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。

- 开闭原则

定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。

解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。

#### 总结

本章学习了这几种模式，这几种模式在node中有很多种实现方式，没有一个标准，但是我们只要学习到这些模式的思想和要解决的问题，就可以了，等到遇见具体的问题，我们可以设计自己方式来实现这些有趣的模式。学习这些模块可以通过将这些模式分为三大类进行学习，一种是创建型模式、另一种是结构型模式、另一种是行为型模式。具体我们可以通过下面两个教程来了解目前面向对象的设计模式，主要是学习思想和解决的问题。后面我们了解了node的设计原则和设计模式遵守的原则。

- [菜鸟教程](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)
- [java中设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html)

